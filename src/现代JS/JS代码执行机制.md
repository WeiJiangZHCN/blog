# JS代码执行机制

## 执行上下文栈

JS引擎为了执行代码，引擎内部会有一个执行上下文栈（Execution Context Stack，简称ECS），也就是函数调用栈。  
首先入栈的就是全局代码块，也就是将全局代码封装成函数，然后压入栈中执行。

## 初始化全局对象

然后执行全局代码之前会在我们的堆内存创建一个全局对象：Global Object（简称GO）。相当于预导入模块，作用如下：

1. 对象里面会包含一些全局的方法和类，像Math、Date、String、Array、setTimeout等等；
2. 其中有一个window属性是指向该全局对象自身的；
3. 该对象中会收集我们全局定义的变量，并设置成undefined；(也就是变量提升)

## 执行全局代码

遇到什么语句就执行对应的含义，如遇到函数执行，就会根据函数体(初始化GO的时候便把函数体放到堆中了，栈中变量有其指针)创建一个函数执行上下文（Functional Execution Context，简称FEC），并且加入到执行上下文栈（ECS）中。  
函数执行上下文（FEC）包含三部分内容：

1. AO：在解析函数时，会创建一个Activation Objec（AO）；
2. 作用域链：由函数VO和父级VO组成，查找是一层层往外层查找；
3. this指向：this绑定的值，在函数执行时确定；

其实全局执行上下文（GEC）也有自己的作用域链和this指向，只是它对应的作用域链就是自己本身，而this指向为window。

## 环境记录

可分为两种：  
声明式环境记录： 储存了作用范围中关于变量，const、let、class....的声明。  
对象式环境记录： 记录通过 var 声明的标识符。是VO(variable object)实现的规范.

每个环境记录都有一个[[OuterEnv]]字段，它要么是空的，要么是对外部环境记录的引用。
声明式环境记录的优点：
声明式环境记录declarative environment records允许使用完整的词法寻址技术 lexical addressing ，即直接访问需要的变量，而不需要通过任何作用域链查找，无论其嵌套深度如何都不会影响性能。

### 块级作用域

什么时候会创建执行上下文？是某个函数被执行的时候。  
那么显然，运行块级作用域中的代码并不会创建执行上下文。但是在环境记录的定义中，遇到BlockStatement，会创建一个新的环境记录，用于管理块中的变量。这个新的词法环境就是声明式环境记录。  
所以，由let/const声明的变量会被最近的词法环境所管理。通过 var 声明的变量不能由词法环境管理，因此会逸出到最近的变量环境上。  

### 闭包
闭包可以创建独立的环境记录。

```js
function foo() {
    let a = 1;
    let b = 2;
    return function() {
        a = a+1
        console.log(a);
        b = b+1
        console.log(b);
    }
}
const bar = foo();
const bar2 = foo();
bar();//输出2,3
bar2();//输出2,3
```

两次调用foo函数，创建二个的函数执行上下文，而每次函数执行上下文都会创建一个新的环境记录，bar和bar2分别引用不同的环境记录，所以会形成两个独立的闭包。
